"""Pytest JSON parser for test results.

This parser extracts test results from pytest JSON format files
(generated by pytest-json-report or similar plugins).
"""

from __future__ import annotations

import json
import re
from pathlib import Path
from typing import Any


class PytestJSONParser:
    """Parser for Pytest JSON test result files.

    Parses JSON output from pytest-json-report or similar pytest plugins.
    """

    # Pattern for requirement IDs in test names (handles both hyphens and underscores)
    REQ_PATTERN = re.compile(
        r"REQ[-_]([A-Za-z]?\d+(?:[-_][A-Z])?)",
        re.IGNORECASE,
    )

    def parse(self, content: str, source_path: str) -> list[dict[str, Any]]:
        """Parse Pytest JSON content and return test result dicts.

        Args:
            content: JSON file content.
            source_path: Path to the source file.

        Returns:
            List of test result dictionaries with keys:
            - id: Unique test ID
            - name: Test name
            - classname: Test class/module name
            - status: passed, failed, skipped, or error
            - duration: Test duration in seconds
            - message: Error/failure message (if any)
            - validates: List of requirement IDs this test validates
        """
        results: list[dict[str, Any]] = []

        try:
            data = json.loads(content)
        except json.JSONDecodeError:
            return results

        # Handle pytest-json-report format
        if "tests" in data:
            for test in data["tests"]:
                result = self._parse_pytest_json_report_test(test, source_path)
                if result:
                    results.append(result)
        # Handle simpler format with just a list of tests
        elif isinstance(data, list):
            for test in data:
                result = self._parse_simple_test(test, source_path)
                if result:
                    results.append(result)

        return results

    def _parse_pytest_json_report_test(
        self, test: dict[str, Any], source_path: str
    ) -> dict[str, Any] | None:
        """Parse a test from pytest-json-report format.

        Args:
            test: Test dict from pytest-json-report.
            source_path: Path to the source file.

        Returns:
            Parsed test result dict or None.
        """
        nodeid = test.get("nodeid", "")
        outcome = test.get("outcome", "passed")

        # Parse nodeid to get module and test name
        # Format: path/to/test.py::TestClass::test_method
        # or: path/to/test.py::test_function
        parts = nodeid.split("::")
        if len(parts) >= 2:
            classname = parts[0]
            name = "::".join(parts[1:])
        else:
            classname = ""
            name = nodeid

        # Map outcome to status
        status_map = {
            "passed": "passed",
            "failed": "failed",
            "skipped": "skipped",
            "error": "error",
            "xfailed": "skipped",  # Expected failure
            "xpassed": "passed",  # Unexpected pass
        }
        status = status_map.get(outcome, "passed")

        # Get duration
        duration = 0.0
        if "duration" in test:
            duration = float(test["duration"])
        elif "call" in test and "duration" in test["call"]:
            duration = float(test["call"]["duration"])

        # Get message from call or setup/teardown
        message = None
        for phase in ["call", "setup", "teardown"]:
            if phase in test:
                phase_data = test[phase]
                if isinstance(phase_data, dict):
                    if "longrepr" in phase_data:
                        message = str(phase_data["longrepr"])[:200]
                        break
                    elif "message" in phase_data:
                        message = str(phase_data["message"])[:200]
                        break

        # Extract requirement references
        validates = self._extract_req_ids(f"{classname} {name}")

        return {
            "id": f"{source_path}::{nodeid}",
            "name": name,
            "classname": classname,
            "status": status,
            "duration": duration,
            "message": message,
            "validates": validates,
            "source_path": source_path,
        }

    def _parse_simple_test(
        self, test: dict[str, Any], source_path: str
    ) -> dict[str, Any] | None:
        """Parse a test from simple list format.

        Args:
            test: Test dict with name, status, etc.
            source_path: Path to the source file.

        Returns:
            Parsed test result dict or None.
        """
        name = test.get("name", "")
        if not name:
            return None

        classname = test.get("classname", test.get("module", ""))
        status = test.get("status", test.get("outcome", "passed"))

        # Normalize status
        status_map = {
            "pass": "passed",
            "passed": "passed",
            "fail": "failed",
            "failed": "failed",
            "skip": "skipped",
            "skipped": "skipped",
            "error": "error",
        }
        status = status_map.get(status.lower(), "passed")

        duration = float(test.get("duration", 0))
        message = test.get("message", test.get("longrepr"))
        if message:
            message = str(message)[:200]

        validates = self._extract_req_ids(f"{classname} {name}")

        return {
            "id": f"{source_path}:{classname}::{name}",
            "name": name,
            "classname": classname,
            "status": status,
            "duration": duration,
            "message": message,
            "validates": validates,
            "source_path": source_path,
        }

    def _extract_req_ids(self, text: str) -> list[str]:
        """Extract requirement IDs from text.

        Args:
            text: Text to search for requirement IDs.

        Returns:
            List of normalized requirement IDs (using hyphens).
        """
        req_ids = []

        # Find all REQ-xxx patterns
        # Assertion suffix must be a single uppercase letter NOT followed by lowercase
        # This prevents matching REQ_p00001_login as REQ-p00001-l
        for match in re.finditer(
            r"REQ[-_]([A-Za-z]?\d+(?:[-_][A-Z](?![a-z]))?)",
            text,
            re.IGNORECASE,
        ):
            # Normalize: replace underscores with hyphens
            req_id = f"REQ-{match.group(1).replace('_', '-')}"
            if req_id not in req_ids:
                req_ids.append(req_id)

        return req_ids

    def can_parse(self, file_path: Path) -> bool:
        """Check if this parser can handle the given file.

        Args:
            file_path: Path to the file.

        Returns:
            True for JSON files that look like pytest results.
        """
        name = file_path.name.lower()
        return file_path.suffix.lower() == ".json" and (
            "pytest" in name or "test" in name or "result" in name
        )


def create_parser() -> PytestJSONParser:
    """Factory function to create a PytestJSONParser.

    Returns:
        New PytestJSONParser instance.
    """
    return PytestJSONParser()
