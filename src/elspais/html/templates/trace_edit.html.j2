{# Implements: REQ-p00006-A, REQ-d00010-A, REQ-d00010-G #}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trace Edit - Requirements Editor</title>
    <style>
/* Implements: REQ-p00006-A */
{% include "partials/css/_base.css.j2" %}
/* Edit body overrides */
body {
    overflow: hidden;
    height: 100vh;
    display: flex;
    flex-direction: column;
}
{% include "partials/css/_header-edit.css.j2" %}
{% include "partials/css/_buttons.css.j2" %}
{% include "partials/css/_toast.css.j2" %}
{% include "partials/css/_nav-panel.css.j2" %}
{% include "partials/css/_dividers.css.j2" %}
{% include "partials/css/_card-stack.css.j2" %}
{% include "partials/css/_edit-mode.css.j2" %}
{% include "partials/css/_file-viewer-edit.css.j2" %}
{% include "partials/css/_dark-theme.css.j2" %}
/* Edit responsive */
@media (max-width: 768px) {
    .header { flex-direction: column; align-items: flex-start; }
    .header-center { min-width: 100%; }
    .layout { flex-direction: column; }
    .nav-panel { width: 100% !important; max-width: 100% !important; height: 40vh; border-right: none; border-bottom: 1px solid #e9ecef; }
    .file-viewer-panel { width: 100% !important; max-width: 100% !important; border-left: none; border-top: 1px solid #e9ecef; }
}
    </style>
</head>
<body>

<!-- =====================================================================
     HEADER
     ===================================================================== -->

{% include "partials/_header.html.j2" %}

<!-- =====================================================================
     TOAST CONTAINER
     ===================================================================== -->

{% include "partials/_toast_container.html.j2" %}

<!-- =====================================================================
     3-PANEL LAYOUT
     ===================================================================== -->

<div class="layout" id="layout">

    <!-- Nav Panel (Left) -->
    <nav class="nav-panel" id="nav-panel">
        <div class="nav-tabs">
            <button class="nav-tab active" data-kind="req" onclick="switchNavTab('req')">Req</button>
            <button class="nav-tab" data-kind="code" onclick="switchNavTab('code')">Code</button>
            <button class="nav-tab" data-kind="test" onclick="switchNavTab('test')">Tests</button>
            <button class="nav-tab" data-kind="journey" onclick="switchNavTab('journey')">Journeys</button>
        </div>
        <div class="nav-tree-container" id="nav-tree-container">
            <div style="padding:20px;color:#adb5bd;text-align:center;font-size:0.85rem;">Loading tree...</div>
        </div>
    </nav>

    <!-- Divider 1 (nav | cards) -->
    <div class="divider" id="divider-left"></div>

    <!-- Card Stack (Center) -->
    <div class="card-stack-panel" id="card-stack-panel">
        <div class="card-stack-header">
            <span id="card-stack-count">No cards open</span>
            <button class="btn" onclick="closeAllCards()" style="padding:3px 8px;font-size:0.75rem;">Close All</button>
        </div>
        <div class="card-stack-body" id="card-stack-body">
            <div class="card-stack-empty" id="card-stack-empty">
                <div class="card-stack-empty-icon">&#128196;</div>
                <div>Click a requirement in the tree to open it</div>
                <div style="font-size:0.75rem;">Cards will appear here</div>
            </div>
        </div>
    </div>

    <!-- Divider 2 (cards | file viewer) -->
    <div class="divider" id="divider-right" style="display:none;"></div>

    <!-- File Viewer Panel (Right) -->
    {% include "partials/_file_viewer.html.j2" %}

</div>

<!-- =====================================================================
     JAVASCRIPT
     ===================================================================== -->

<script>
// =====================================================================
// State
// =====================================================================

const editState = {
    enabled: false,
    openCards: new Map(),       // nodeId -> {data, collapsed}
    openCardOrder: [],          // nodeId[] — most recent first
    dirtyFields: new Map(),     // fieldKey -> {endpoint, payload, original}
    mutationCount: 0,
    activeNavTab: 'req',
    treeData: [],
    collapsedTreeNodes: new Set(),
    searchDebounce: null
};

// =====================================================================
// Cookie Persistence
// =====================================================================

const COOKIE_NAME = 'elspais_trace_edit_state';
const COOKIE_DAYS = 30;

function saveState() {
    const stateToSave = {
        editEnabled: editState.enabled,
        openCardIds: editState.openCardOrder,
        activeNavTab: editState.activeNavTab,
        collapsedTreeNodes: Array.from(editState.collapsedTreeNodes),
        collapsedCards: []
    };
    // Track which cards are collapsed
    editState.openCards.forEach((info, id) => {
        if (info.collapsed) stateToSave.collapsedCards.push(id);
    });
    const expires = new Date(Date.now() + COOKIE_DAYS * 864e5).toUTCString();
    document.cookie = COOKIE_NAME + '=' + encodeURIComponent(JSON.stringify(stateToSave)) +
        '; expires=' + expires + '; path=/; SameSite=Lax';
}

function loadState() {
    const match = document.cookie.match(new RegExp('(^| )' + COOKIE_NAME + '=([^;]+)'));
    if (!match) return null;
    try {
        return JSON.parse(decodeURIComponent(match[2]));
    } catch (e) {
        return null;
    }
}

// =====================================================================
// API Helpers
// =====================================================================

async function apiFetch(url, options) {
    try {
        const resp = await fetch(url, options);
        const data = await resp.json();
        if (!resp.ok && data.error) {
            showToast(data.error, 'error');
            return null;
        }
        return data;
    } catch (err) {
        showToast('Network error: ' + err.message, 'error');
        return null;
    }
}

async function mutate(endpoint, payload) {
    const data = await apiFetch(endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
    });
    if (data && data.success) {
        showToast('Change applied', 'success');
        await refreshDirtyCount();
    } else if (data) {
        showToast(data.error || 'Mutation failed', 'error');
    }
    return data;
}

// =====================================================================
// Toast Notifications
// =====================================================================

function showToast(message, type) {
    type = type || 'info';
    const container = document.getElementById('toast-container');
    const toast = document.createElement('div');
    toast.className = 'toast ' + type;
    toast.textContent = message;
    container.appendChild(toast);
    setTimeout(function() {
        toast.style.opacity = '0';
        toast.style.transition = 'opacity 0.3s';
        setTimeout(function() { toast.remove(); }, 300);
    }, 3000);
}

// =====================================================================
// Header Stats
// =====================================================================

async function loadStats() {
    const data = await apiFetch('/api/status');
    if (!data) return;
    const counts = data.counts || {};
    document.getElementById('stat-prd').textContent = 'PRD: ' + (counts.prd || 0);
    document.getElementById('stat-ops').textContent = 'OPS: ' + (counts.ops || 0);
    document.getElementById('stat-dev').textContent = 'DEV: ' + (counts.dev || 0);
}

async function refreshDirtyCount() {
    const data = await apiFetch('/api/dirty');
    if (!data) return;
    editState.mutationCount = data.mutation_count || 0;
    const badge = document.getElementById('unsaved-badge');
    const btnSave = document.getElementById('btn-save');
    const btnRevert = document.getElementById('btn-revert');
    const btnUndo = document.getElementById('btn-undo');
    if (editState.mutationCount > 0) {
        badge.textContent = editState.mutationCount;
        badge.classList.remove('hidden');
        btnSave.disabled = false;
        btnRevert.disabled = false;
        btnUndo.disabled = false;
    } else {
        badge.classList.add('hidden');
        btnSave.disabled = true;
        btnRevert.disabled = true;
        btnUndo.disabled = true;
    }
}

// =====================================================================
// Nav Tree
// =====================================================================

async function loadTreeData() {
    const data = await apiFetch('/api/tree-data');
    if (!data) return;
    editState.treeData = data;
    renderNavTree();
}

function renderNavTree() {
    const container = document.getElementById('nav-tree-container');
    const activeTab = editState.activeNavTab;
    const rows = editState.treeData;

    if (!rows || rows.length === 0) {
        container.innerHTML = '<div style="padding:20px;color:#adb5bd;text-align:center;font-size:0.85rem;">No items found</div>';
        return;
    }

    // Filter by tab
    let filteredRows;
    if (activeTab === 'req') {
        filteredRows = rows.filter(function(r) { return r.level && r.level !== ''; });
    } else {
        // For code/test/journey — we only have requirement rows from tree-data
        // Show all rows but these tabs will display a "coming soon" message
        filteredRows = rows;
    }

    if (activeTab !== 'req') {
        container.innerHTML = '<div style="padding:20px;color:#adb5bd;text-align:center;font-size:0.85rem;">' +
            activeTab.charAt(0).toUpperCase() + activeTab.slice(1) +
            ' nodes are visible in the requirement tree hierarchy.</div>';
        return;
    }

    let html = '';
    filteredRows.forEach(function(row) {
        // Determine if collapsed
        const isCollapsed = editState.collapsedTreeNodes.has(row.id);
        // Check if parent is collapsed (skip rendering)
        if (row.depth > 0 && isAncestorCollapsed(row, filteredRows)) {
            return; // don't render
        }

        const indents = [];
        for (let i = 0; i < row.depth; i++) {
            indents.push('<span class="nav-tree-indent"></span>');
        }

        const toggleClass = row.has_children
            ? (isCollapsed ? 'nav-tree-toggle' : 'nav-tree-toggle')
            : 'nav-tree-toggle leaf';
        const toggleIcon = row.has_children
            ? (isCollapsed ? '&#9654;' : '&#9660;')
            : '';

        const selectedClass = editState.openCards.has(row.id) ? ' selected' : '';
        const levelClass = row.level ? row.level.toLowerCase() : '';
        const shortId = row.id.replace('REQ-', '');

        html += '<div class="nav-tree-row' + selectedClass + '" ' +
            'data-id="' + row.id + '" ' +
            'data-parent="' + (row.parent_id || '') + '" ' +
            'data-depth="' + row.depth + '" ' +
            'onclick="openCard(\'' + row.id + '\')">' +
            indents.join('') +
            '<button class="' + toggleClass + '" onclick="event.stopPropagation(); toggleTreeNode(\'' + row.id + '\')">' +
            toggleIcon + '</button>' +
            (levelClass ? '<span class="nav-tree-level ' + levelClass + '">' + row.level + '</span>' : '') +
            '<span class="nav-tree-id">' + shortId + '</span>' +
            '<span class="nav-tree-title">' + escapeHtml(row.title || '') + '</span>' +
            '</div>';
    });

    container.innerHTML = html;
}

function isAncestorCollapsed(row, allRows) {
    if (!row.parent_id) return false;
    // Walk up the parent chain
    let parentId = row.parent_id;
    while (parentId) {
        if (editState.collapsedTreeNodes.has(parentId)) return true;
        // Find parent row
        const parentRow = allRows.find(function(r) { return r.id === parentId; });
        if (!parentRow) break;
        parentId = parentRow.parent_id;
    }
    return false;
}

function toggleTreeNode(nodeId) {
    if (editState.collapsedTreeNodes.has(nodeId)) {
        editState.collapsedTreeNodes.delete(nodeId);
    } else {
        editState.collapsedTreeNodes.add(nodeId);
    }
    renderNavTree();
    saveState();
}

function switchNavTab(kind) {
    editState.activeNavTab = kind;
    document.querySelectorAll('.nav-tab').forEach(function(tab) {
        tab.classList.toggle('active', tab.dataset.kind === kind);
    });
    renderNavTree();
    saveState();
}

// =====================================================================
// Card Stack
// =====================================================================

async function openCard(nodeId) {
    // If already open, just focus it
    if (editState.openCards.has(nodeId)) {
        focusCard(nodeId);
        return;
    }

    // Fetch requirement data
    const data = await apiFetch('/api/requirement/' + encodeURIComponent(nodeId));
    if (!data) return;

    // Store in state
    editState.openCards.set(nodeId, { data: data, collapsed: false });

    // Add to front of order
    editState.openCardOrder = editState.openCardOrder.filter(function(id) { return id !== nodeId; });
    editState.openCardOrder.unshift(nodeId);

    renderCardStack();
    focusCard(nodeId);
    updateNavSelection();
    saveState();
}

function closeCard(nodeId) {
    editState.openCards.delete(nodeId);
    editState.openCardOrder = editState.openCardOrder.filter(function(id) { return id !== nodeId; });
    renderCardStack();
    updateNavSelection();
    saveState();
}

function focusCard(nodeId) {
    // Move to front of order
    editState.openCardOrder = editState.openCardOrder.filter(function(id) { return id !== nodeId; });
    editState.openCardOrder.unshift(nodeId);

    // Remove focused class from all, add to target
    document.querySelectorAll('.req-card').forEach(function(c) { c.classList.remove('focused'); });
    const card = document.getElementById('card-' + nodeId);
    if (card) {
        card.classList.add('focused');
        card.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }

    renderCardStack();
    saveState();
}

function toggleCardCollapse(nodeId) {
    const info = editState.openCards.get(nodeId);
    if (!info) return;
    info.collapsed = !info.collapsed;
    const card = document.getElementById('card-' + nodeId);
    if (card) {
        card.classList.toggle('collapsed', info.collapsed);
    }
    saveState();
}

function closeAllCards() {
    editState.openCards.clear();
    editState.openCardOrder = [];
    renderCardStack();
    updateNavSelection();
    saveState();
}

function renderCardStack() {
    const body = document.getElementById('card-stack-body');
    const empty = document.getElementById('card-stack-empty');
    const countEl = document.getElementById('card-stack-count');

    if (editState.openCardOrder.length === 0) {
        body.innerHTML = '';
        body.appendChild(empty);
        empty.style.display = 'flex';
        countEl.textContent = 'No cards open';
        return;
    }

    empty.style.display = 'none';
    countEl.textContent = editState.openCardOrder.length + ' card' +
        (editState.openCardOrder.length !== 1 ? 's' : '') + ' open';

    let html = '';
    editState.openCardOrder.forEach(function(nodeId) {
        const info = editState.openCards.get(nodeId);
        if (!info) return;
        html += buildCardHtml(nodeId, info.data, info.collapsed);
    });

    body.innerHTML = html;

    // Re-add empty element (hidden) for later
    body.appendChild(empty);
}

function buildCardHtml(nodeId, data, collapsed) {
    const collapsedClass = collapsed ? ' collapsed' : '';
    const focusedClass = editState.openCardOrder[0] === nodeId ? ' focused' : '';
    const shortId = nodeId.replace('REQ-', '');
    const title = escapeHtml(data.title || '');
    const level = (data.level || '').toUpperCase();
    const status = (data.status || '').toLowerCase();
    const statusDisplay = status.charAt(0).toUpperCase() + status.slice(1);
    const hash = data.hash || '';
    const sourcePath = (data.source && data.source.path) || '';
    const sourceLine = (data.source && data.source.line) || 0;

    let html = '<div class="req-card' + collapsedClass + focusedClass + '" id="card-' + nodeId + '">';

    // Header
    html += '<div class="req-card-header" onclick="toggleCardCollapse(\'' + nodeId + '\')">';
    html += '<span class="req-card-expand">&#9660;</span>';
    html += '<span class="req-card-id">' + shortId + '</span>';
    html += '<span class="req-card-title-display">' + title + '</span>';
    html += '<button class="req-card-close" onclick="event.stopPropagation(); closeCard(\'' + nodeId + '\')" title="Close card">&times;</button>';
    html += '</div>';

    // Body
    html += '<div class="req-card-body">';

    // Metadata section
    html += '<div class="card-section"><div class="card-section-label">Metadata</div>';
    html += '<div class="card-meta">';

    // Level
    html += '<div class="card-meta-item">';
    html += '<span class="card-meta-key">Level:</span>';
    html += '<span class="card-meta-value">' + level + '</span>';
    html += '</div>';

    // Status (badge or select)
    html += '<div class="card-meta-item">';
    html += '<span class="card-meta-key">Status:</span>';
    html += '<span class="status-badge-wrapper"><span class="status-badge ' + status + '">' + statusDisplay + '</span></span>';
    html += '<span class="status-select-wrapper edit-only">';
    html += '<select class="status-select" data-node-id="' + nodeId + '" data-original="' + status + '" onchange="onStatusChange(this)">';
    ['Active', 'Draft', 'Deprecated', 'Proposed'].forEach(function(s) {
        const sel = s.toLowerCase() === status ? ' selected' : '';
        html += '<option value="' + s + '"' + sel + '>' + s + '</option>';
    });
    html += '</select></span>';
    html += '</div>';

    // Hash
    html += '<div class="card-meta-item">';
    html += '<span class="card-meta-key">Hash:</span>';
    html += '<span class="card-meta-value" style="font-family:monospace;font-size:0.75rem;">' + hash + '</span>';
    html += '</div>';

    // Source
    if (sourcePath) {
        html += '<div class="card-meta-item">';
        html += '<span class="card-meta-key">Source:</span>';
        html += '<a class="card-meta-value" href="#" onclick="event.preventDefault(); showSource(\'' +
            escapeHtml(sourcePath) + '\', ' + sourceLine + ')" ' +
            'style="color:#0d6efd;cursor:pointer;font-size:0.75rem;text-decoration:none;">' +
            escapeHtml(sourcePath.split('/').pop()) + ':' + sourceLine + '</a>';
        html += '</div>';
    }

    html += '</div></div>';

    // Editable Title (edit mode only, replaces header title on blur)
    html += '<div class="card-section edit-only" style="display:none;"><div class="card-section-label">Title</div>';
    html += '<div class="editable-field" contenteditable="true" data-node-id="' + nodeId + '" ' +
        'data-field="title" data-original="' + escapeAttr(data.title || '') + '" ' +
        'onblur="onTitleBlur(this)" onkeydown="onEditableKeydown(event)">' +
        escapeHtml(data.title || '') + '</div>';
    html += '</div>';

    // Parents section
    if (data.parents && data.parents.length > 0) {
        html += '<div class="card-section"><div class="card-section-label">Implements / Refines</div>';
        html += '<div class="card-parents">';
        data.parents.forEach(function(p) {
            const edgeKind = (p.edge_kind || 'implements').toUpperCase();
            html += '<a class="card-parent-link" href="#" onclick="event.preventDefault(); openCard(\'' + p.id + '\')">';
            html += '<span class="card-parent-kind">' + edgeKind + '</span> ';
            html += p.id.replace('REQ-', '') + ' - ' + escapeHtml(p.title || '');
            html += '</a>';
        });
        html += '</div></div>';
    }

    // Assertions section
    const assertions = (data.children || []).filter(function(c) { return c.kind === 'assertion'; });
    if (assertions.length > 0) {
        html += '<div class="card-section"><div class="card-section-label">Assertions (' + assertions.length + ')</div>';
        html += '<div class="card-assertions">';
        assertions.forEach(function(a) {
            const assertionId = a.id || '';
            const label = a.label || '';
            const text = a.text || '';
            html += '<div class="card-assertion" data-assertion-id="' + assertionId + '">';
            html += '<span class="card-assertion-label">' + label + '</span>';
            html += '<span class="card-assertion-text editable-field" ' +
                'contenteditable="false" data-assertion-id="' + assertionId + '" ' +
                'data-field="assertion" data-original="' + escapeAttr(text) + '" ' +
                'onblur="onAssertionBlur(this)" onkeydown="onEditableKeydown(event)">' +
                escapeHtml(text) + '</span>';
            html += '</div>';
        });
        html += '</div>';

        // Add assertion button (edit mode only)
        html += '<button class="card-add-assertion-btn edit-only" onclick="onAddAssertion(\'' + nodeId + '\')" style="display:none;">+ Add Assertion</button>';
        html += '</div>';
    } else {
        html += '<div class="card-section"><div class="card-section-label">Assertions</div>';
        html += '<div style="font-size:0.8rem;color:#adb5bd;">No assertions defined</div>';
        html += '<button class="card-add-assertion-btn edit-only" onclick="onAddAssertion(\'' + nodeId + '\')" style="display:none;">+ Add Assertion</button>';
        html += '</div>';
    }

    // Children (requirements only)
    const childReqs = (data.children || []).filter(function(c) {
        return c.kind === 'requirement';
    });
    if (childReqs.length > 0) {
        html += '<div class="card-section"><div class="card-section-label">Children (' + childReqs.length + ')</div>';
        html += '<div class="card-children">';
        childReqs.forEach(function(c) {
            html += '<a class="card-child-link" href="#" onclick="event.preventDefault(); openCard(\'' + c.id + '\')">';
            html += c.id.replace('REQ-', '');
            if (c.title) html += ' - ' + escapeHtml(c.title);
            html += '</a>';
        });
        html += '</div></div>';
    }

    html += '</div>'; // end req-card-body
    html += '</div>'; // end req-card

    return html;
}

function updateNavSelection() {
    document.querySelectorAll('.nav-tree-row').forEach(function(row) {
        row.classList.toggle('selected', editState.openCards.has(row.dataset.id));
    });
}

// =====================================================================
// Edit Mode
// =====================================================================

function toggleEditMode() {
    editState.enabled = !editState.enabled;
    document.body.classList.toggle('edit-mode', editState.enabled);
    document.getElementById('edit-toggle').classList.toggle('active', editState.enabled);

    // Toggle contenteditable on assertion text fields
    document.querySelectorAll('.card-assertion-text').forEach(function(el) {
        el.contentEditable = editState.enabled ? 'true' : 'false';
    });

    // Show/hide edit-only elements
    document.querySelectorAll('.edit-only').forEach(function(el) {
        el.style.display = editState.enabled ? '' : 'none';
    });

    saveState();
}

// =====================================================================
// Edit Handlers
// =====================================================================

function onStatusChange(selectEl) {
    const nodeId = selectEl.dataset.nodeId;
    const newStatus = selectEl.value;
    const original = selectEl.dataset.original;

    if (newStatus.toLowerCase() === original) {
        selectEl.classList.remove('dirty');
        return;
    }

    selectEl.classList.add('dirty');
    mutate('/api/mutate/status', { node_id: nodeId, new_status: newStatus }).then(function(result) {
        if (result && result.success) {
            selectEl.dataset.original = newStatus.toLowerCase();
            selectEl.classList.remove('dirty');
            // Refresh the card data
            refreshCard(nodeId);
        }
    });
}

function onTitleBlur(el) {
    if (!editState.enabled) return;
    const nodeId = el.dataset.nodeId;
    const newTitle = el.textContent.trim();
    const original = el.dataset.original;

    if (newTitle === original) {
        el.classList.remove('dirty');
        return;
    }

    if (!newTitle) {
        el.textContent = original;
        el.classList.remove('dirty');
        showToast('Title cannot be empty', 'error');
        return;
    }

    el.classList.add('dirty');
    mutate('/api/mutate/title', { node_id: nodeId, new_title: newTitle }).then(function(result) {
        if (result && result.success) {
            el.dataset.original = newTitle;
            el.classList.remove('dirty');
            refreshCard(nodeId);
        } else {
            el.textContent = original;
            el.classList.remove('dirty');
        }
    });
}

function onAssertionBlur(el) {
    if (!editState.enabled) return;
    const assertionId = el.dataset.assertionId;
    const newText = el.textContent.trim();
    const original = el.dataset.original;

    if (newText === original) {
        el.classList.remove('dirty');
        return;
    }

    if (!newText) {
        el.textContent = original;
        el.classList.remove('dirty');
        showToast('Assertion text cannot be empty', 'error');
        return;
    }

    el.classList.add('dirty');
    mutate('/api/mutate/assertion', { assertion_id: assertionId, new_text: newText }).then(function(result) {
        if (result && result.success) {
            el.dataset.original = newText;
            el.classList.remove('dirty');
        } else {
            el.textContent = original;
            el.classList.remove('dirty');
        }
    });
}

function onAddAssertion(nodeId) {
    const label = prompt('Assertion label (e.g., A, B, C):');
    if (!label) return;
    const text = prompt('Assertion text (SHALL statement):');
    if (!text) return;

    mutate('/api/mutate/assertion/add', {
        req_id: nodeId,
        label: label.trim().toUpperCase(),
        text: text.trim()
    }).then(function(result) {
        if (result && result.success) {
            refreshCard(nodeId);
        }
    });
}

function onEditableKeydown(event) {
    // Enter key = blur (save)
    if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        event.target.blur();
    }
    // Escape = revert
    if (event.key === 'Escape') {
        event.target.textContent = event.target.dataset.original;
        event.target.classList.remove('dirty');
        event.target.blur();
    }
}

async function refreshCard(nodeId) {
    const data = await apiFetch('/api/requirement/' + encodeURIComponent(nodeId));
    if (!data) return;
    const info = editState.openCards.get(nodeId);
    if (!info) return;
    info.data = data;
    renderCardStack();
    // Restore edit mode state after re-render
    if (editState.enabled) {
        document.querySelectorAll('.card-assertion-text').forEach(function(el) {
            el.contentEditable = 'true';
        });
        document.querySelectorAll('.edit-only').forEach(function(el) {
            el.style.display = '';
        });
    }
}

// =====================================================================
// Save / Revert / Undo
// =====================================================================

async function doSave() {
    const result = await mutate('/api/save', {});
    if (result && result.success) {
        showToast('Saved to disk', 'success');
    }
    // Even if it returns 501 (not yet implemented), display message
    if (result && result.message) {
        showToast(result.message, 'info');
    }
}

async function doRevert() {
    if (!confirm('Revert all unsaved changes? This cannot be undone.')) return;
    const result = await mutate('/api/revert', {});
    if (result && result.success) {
        showToast('All changes reverted', 'success');
        // Reload all open cards
        editState.openCardOrder.forEach(function(id) {
            refreshCard(id);
        });
    }
    if (result && result.message) {
        showToast(result.message, 'info');
    }
}

async function doUndo() {
    const result = await mutate('/api/mutate/undo', {});
    if (result && result.success) {
        // Reload all open cards to reflect undo
        editState.openCardOrder.forEach(function(id) {
            refreshCard(id);
        });
    }
}

// =====================================================================
// Search
// =====================================================================

function initSearch() {
    const input = document.getElementById('search-input');
    const results = document.getElementById('search-results');

    input.addEventListener('input', function() {
        clearTimeout(editState.searchDebounce);
        const query = input.value.trim();
        if (query.length < 2) {
            results.classList.remove('visible');
            return;
        }
        editState.searchDebounce = setTimeout(function() {
            performSearch(query);
        }, 250);
    });

    input.addEventListener('focus', function() {
        if (results.children.length > 0 && input.value.trim().length >= 2) {
            results.classList.add('visible');
        }
    });

    // Close search results on click outside
    document.addEventListener('click', function(e) {
        if (!document.getElementById('search-box').contains(e.target)) {
            results.classList.remove('visible');
        }
    });

    // Keyboard navigation
    input.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            results.classList.remove('visible');
            input.blur();
        }
        if (e.key === 'Enter') {
            const first = results.querySelector('.search-result-item');
            if (first) {
                first.click();
                results.classList.remove('visible');
            }
        }
    });
}

async function performSearch(query) {
    const data = await apiFetch('/api/search?q=' + encodeURIComponent(query));
    const results = document.getElementById('search-results');
    if (!data || data.length === 0) {
        results.innerHTML = '<div style="padding:12px;color:#adb5bd;text-align:center;font-size:0.8rem;">No results</div>';
        results.classList.add('visible');
        return;
    }

    let html = '';
    data.slice(0, 20).forEach(function(item) {
        const level = (item.level || '').toUpperCase();
        const levelColor = level === 'PRD' ? '#212529'
            : level === 'OPS' ? '#fd7e14'
            : level === 'DEV' ? '#20c997' : '#6c757d';
        html += '<div class="search-result-item" onclick="openCard(\'' + item.id + '\'); ' +
            'document.getElementById(\'search-results\').classList.remove(\'visible\');">';
        html += '<span class="search-result-level" style="background:' + levelColor + ';color:white;">' + level + '</span>';
        html += '<span class="search-result-id">' + item.id.replace('REQ-', '') + '</span>';
        html += '<span class="search-result-title">' + escapeHtml(item.title || '') + '</span>';
        html += '</div>';
    });

    results.innerHTML = html;
    results.classList.add('visible');
}

// =====================================================================
// File Viewer
// =====================================================================

async function showSource(filePath, lineNumber) {
    const panel = document.getElementById('file-viewer-panel');
    const divider = document.getElementById('divider-right');
    const pathEl = document.getElementById('fv-path');
    const statusEl = document.getElementById('fv-status');
    const body = document.getElementById('fv-body');

    pathEl.textContent = filePath;
    pathEl.title = filePath;
    statusEl.textContent = '';
    statusEl.className = 'fv-status';

    // Show panel and divider
    panel.classList.add('open');
    divider.style.display = '';

    // Show loading state
    body.innerHTML = '<div style="padding:24px;color:#adb5bd;text-align:center;">Loading...</div>';

    try {
        const resp = await fetch('/api/file-content?path=' + encodeURIComponent(filePath));
        if (!resp.ok) {
            const err = await resp.json().catch(function() { return {}; });
            body.innerHTML = '<div style="padding:24px;color:#dc3545;text-align:center;">' +
                escapeHtml(err.error || 'Failed to load file') + '</div>';
            return;
        }
        const data = await resp.json();

        // Update status badge
        if (data.has_pending_mutations) {
            statusEl.textContent = data.pending_mutation_count + ' pending edit' +
                (data.pending_mutation_count !== 1 ? 's' : '');
            statusEl.className = 'fv-status has-mutations';
            statusEl.title = 'Unsaved mutations would modify this file: ' +
                (data.affected_nodes || []).join(', ');
        } else {
            statusEl.textContent = 'on disk';
            statusEl.className = 'fv-status on-disk';
            statusEl.title = 'Showing current file contents from disk';
        }

        // Render lines with line numbers
        var html = '<div class="source-table" role="presentation">';
        var lines = data.lines || [];
        for (var i = 0; i < lines.length; i++) {
            var num = i + 1;
            var cls = 'source-line';
            if (num === lineNumber) cls += ' highlighted';
            html += '<div class="' + cls + '" id="fv-line-' + num + '">' +
                '<span class="line-num">' + num + '</span>' +
                '<span class="line-content">' + escapeHtml(lines[i]) + '</span>' +
                '</div>';
        }
        html += '</div>';
        body.innerHTML = html;

        // Scroll to the target line
        if (lineNumber > 0) {
            var target = document.getElementById('fv-line-' + lineNumber);
            if (target) {
                setTimeout(function() {
                    target.scrollIntoView({ block: 'center', behavior: 'smooth' });
                }, 100);
            }
        }

    } catch (e) {
        body.innerHTML = '<div style="padding:24px;color:#dc3545;text-align:center;">' +
            'Error loading file: ' + escapeHtml(String(e)) + '</div>';
    }
}

function closeFileViewer() {
    document.getElementById('file-viewer-panel').classList.remove('open');
    document.getElementById('divider-right').style.display = 'none';
}

// =====================================================================
// Resizable Dividers
// =====================================================================

function initDividers() {
    initDivider('divider-left', 'nav-panel', 'left');
    initDivider('divider-right', 'file-viewer-panel', 'right');
}

function initDivider(dividerId, panelId, side) {
    const divider = document.getElementById(dividerId);
    const panel = document.getElementById(panelId);
    const layout = document.getElementById('layout');
    let isDragging = false;

    divider.addEventListener('mousedown', function(e) {
        isDragging = true;
        divider.classList.add('dragging');
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';
        e.preventDefault();
    });

    document.addEventListener('mousemove', function(e) {
        if (!isDragging) return;
        const layoutRect = layout.getBoundingClientRect();
        if (side === 'left') {
            const width = Math.max(150, Math.min(500, e.clientX - layoutRect.left));
            panel.style.width = width + 'px';
        } else {
            const width = Math.max(250, Math.min(layoutRect.width * 0.6, layoutRect.right - e.clientX));
            panel.style.width = width + 'px';
        }
    });

    document.addEventListener('mouseup', function() {
        if (!isDragging) return;
        isDragging = false;
        divider.classList.remove('dragging');
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
        saveState();
    });
}

// =====================================================================
// Keyboard Shortcuts
// =====================================================================

document.addEventListener('keydown', function(e) {
    // Escape closes file viewer first
    if (e.key === 'Escape') {
        if (document.getElementById('file-viewer-panel').classList.contains('open')) {
            closeFileViewer();
        }
    }

    // Ctrl+E toggles edit mode
    if (e.key === 'e' && (e.ctrlKey || e.metaKey)) {
        e.preventDefault();
        toggleEditMode();
    }

    // Ctrl+Z = undo (only when not in a text field)
    if (e.key === 'z' && (e.ctrlKey || e.metaKey) && !e.target.isContentEditable && e.target.tagName !== 'INPUT') {
        e.preventDefault();
        doUndo();
    }

    // Ctrl+K = focus search
    if (e.key === 'k' && (e.ctrlKey || e.metaKey)) {
        e.preventDefault();
        document.getElementById('search-input').focus();
    }
});

// =====================================================================
// Utilities
// =====================================================================

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function escapeAttr(text) {
    return text.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// =====================================================================
// Initialize
// =====================================================================

document.addEventListener('DOMContentLoaded', function() {
    // Load initial data
    loadStats();
    loadTreeData();
    initSearch();
    initDividers();
    refreshDirtyCount();

    // Restore saved state
    const saved = loadState();
    if (saved) {
        // Restore nav tab
        if (saved.activeNavTab) {
            editState.activeNavTab = saved.activeNavTab;
            document.querySelectorAll('.nav-tab').forEach(function(tab) {
                tab.classList.toggle('active', tab.dataset.kind === saved.activeNavTab);
            });
        }

        // Restore edit mode
        if (saved.editEnabled) {
            toggleEditMode();
        }

        // Restore collapsed tree nodes
        if (saved.collapsedTreeNodes && Array.isArray(saved.collapsedTreeNodes)) {
            editState.collapsedTreeNodes = new Set(saved.collapsedTreeNodes);
        }

        // Restore open cards (fetch each)
        if (saved.openCardIds && saved.openCardIds.length > 0) {
            const collapsedSet = new Set(saved.collapsedCards || []);
            // Load cards in reverse so they end up in correct order
            const ids = saved.openCardIds.slice().reverse();
            (async function restoreCards() {
                for (const id of ids) {
                    const data = await apiFetch('/api/requirement/' + encodeURIComponent(id));
                    if (data && !data.error) {
                        editState.openCards.set(id, {
                            data: data,
                            collapsed: collapsedSet.has(id)
                        });
                        editState.openCardOrder.push(id);
                    }
                }
                // Reverse to restore original order (most recent first)
                editState.openCardOrder.reverse();
                renderCardStack();
                updateNavSelection();
                // Restore edit mode state on cards
                if (editState.enabled) {
                    document.querySelectorAll('.card-assertion-text').forEach(function(el) {
                        el.contentEditable = 'true';
                    });
                    document.querySelectorAll('.edit-only').forEach(function(el) {
                        el.style.display = '';
                    });
                }
            })();
        }
    }
});
</script>

</body>
</html>
